'''
Generate starting geometry for LAMMPS

Author: Tawfiqur Rakib (trakib2), Kittithat Krongchon (krongch2)
'''
import ase.io
import numpy as np

def rotation_matrix(theta_rad):
    return np.array((
            [np.cos(theta_rad), -np.sin(theta_rad), 0],
            [np.sin(theta_rad), np.cos(theta_rad), 0],
            [0, 0, 1]
        ))

def get_coordinates(latvec_a, latvec_b, z):
    '''
    Returns the coordinate of a layer before rotation

    params:
        latvec_a: lattice vector of a layer
        latvec_b: lattice vector of a layer (usually 60 degree from the `latvec_a`)
        z: z-coordinate of the layer
    '''
    rb0 = [0, 0]
    rb1 = rb0 + (latvec_a + latvec_b)/3
    nhalf = 500
    ilin = np.arange(-nhalf, nhalf)
    jlin = np.arange(-nhalf, nhalf)
    jv, iv = np.meshgrid(jlin, ilin, indexing='ij')
    coordinates = np.ndarray(shape=(len(jlin), len(ilin), 2, 3))
    coordinates[:, :, 0, 0] = iv*latvec_a[0] + jv*latvec_b[0] + rb0[0]
    coordinates[:, :, 0, 1] = iv*latvec_a[1] + jv*latvec_b[1] + rb0[1]
    coordinates[:, :, 0, 2] = z
    coordinates[:, :, 1, 0] = iv*latvec_a[0] + jv*latvec_b[0] + rb1[0]
    coordinates[:, :, 1, 1] = iv*latvec_a[1] + jv*latvec_b[1] + rb1[1]
    coordinates[:, :, 1, 2] = z
    coordinates = coordinates.reshape(-1, 3)
    return coordinates

def get_final_coord(phi, ss, rotlvmp, coordinates, unique_species, z):
    '''
    Returns supercell of rotated moire pattern for one layer

    params:
        phi: twist angle
        ss: scaling factor
        rotlvmp: rotated lattice vector of the moire pattern
        coordinates: unrotated coordinates from `get_coordinates` function
        unique_species: a list of element symbols, e.g. ['C', 'C'] for twisted bilayer graphene
        z: z-coordinate of the layer
    '''
    rotcoordinates = np.zeros(shape=coordinates.shape)
    rotcoordinates[:, :2] = (rotation_matrix(-phi)[:2, :2] @ coordinates[:, :2].T).T
    tot_mat = 400000
    fincoord = np.ndarray(shape=(tot_mat, 3))
    fincoord.fill(0)
    v=0
    species = []

    for c in range(0, coordinates.shape[0]):
        if (rotcoordinates[c, 0] > -0.0001 and rotcoordinates[c, 0] < ss*rotlvmp[0][0] and
            rotcoordinates[c, 1] > -0.0001 and rotcoordinates[c, 1] < ss*rotlvmp[1][1]):
            fincoord[v, 0] = rotcoordinates[c, 0]
            fincoord[v, 1] = rotcoordinates[c, 1]
            fincoord[v, 2] = z
            if c % 2 == 0:
                species.append(unique_species[0])
            elif c % 2 == 1:
                species.append(unique_species[1])
            v += 1
    return fincoord, species

def get_natoms(fincoords):
    p = 0
    for fincoord in fincoords:
        for i in range(len(fincoord)-1):
            if (fincoord[i, 0] != 0 or fincoord[i+1, 0] != 0):
                p += 1
    natom = int(p)
    return natom

def get_cell_latvec(rotlvmp, cell_height, ss):
    return np.array([
        [rotlvmp[0][0]*ss, 0, 0],
        [0, rotlvmp[1][1]*ss, 0],
        [0, 0, cell_height]
        ])

def get_atomic_mass(symbol):
    return {'B': 10.811, 'N': 14.007, 'C': 12.011}[symbol]

def get_lammps_header(latvec, natoms, species_map):
    mass_map = {}
    for k, atom_id in species_map.items():
        mass = get_atomic_mass(k[1])
        if atom_id not in mass_map:
            mass_map[atom_id] = mass
    mass_section = 'Masses\n\n'
    for atom_id, mass in mass_map.items():
        mass_section += f'{atom_id} {mass}\n'
    mass_section += '\n'

    s = ''
    s += 'autogenerated by geom.py\n\n'
    s += f'{natoms} atoms\n'
    s += f'{len(mass_map)} atom types\n'
    s += f'0 {latvec[0, 0]:.6f} xlo xhi\n'
    s += f'0 {latvec[1, 1]:.6f} ylo yhi\n'
    s += f'0 {latvec[2, 2]:.6f} zlo zhi\n'
    s += '\n'
    s += mass_section
    return s

def get_atom_section(species_layers, fincoords, species_map, latvec):
    natom = get_natoms(fincoords)
    xyz = []
    species_fin = []
    atom_tag = 1
    atom_section = 'Atoms\n\n'
    for layer_idx, (species_layer, fincoord) in enumerate(zip(species_layers, fincoords)):
        layer_tag = layer_idx+1
        for i in range(len(species_layer)):
            x, y, z = fincoord[i, 0], fincoord[i, 1], fincoord[i, 2]
            xyz.append([x, y, z])
            species = species_layer[i]
            species_fin.append(species)
            species_tag = species_map[(layer_tag, species)]
            atom_section += '%d %d %d %d %1.6f %1.6f %1.6f %d %d %d\n'%(atom_tag, layer_tag, species_tag, 0, x, y, z, 0, 0, 0)
            atom_tag += 1
    atoms = ase.Atoms(species_fin, cell=latvec)
    atoms.set_positions(xyz)
    return atom_section, atoms

def write_files(prefix, rotlvmp, cell_height, ss, species_map, species_layers, fincoords):
    natoms = get_natoms(fincoords)
    latvec = get_cell_latvec(rotlvmp, cell_height, ss)
    header = get_lammps_header(latvec, natoms, species_map)
    atom_section, atoms = get_atom_section(species_layers, fincoords, species_map, latvec)

    print(f'writing {prefix}')
    with open(f'{prefix}.txt', 'w') as f:
        f.write(header)
        f.write(atom_section)

    ase.io.write(f'{prefix}.xsf', atoms, format='xsf')

def gen_CCCC(phi, ss, rotlvmp, coordinates1, coordinates2, cell_height, distance, prefix='geom'):
    fincoord1, species_1 = get_final_coord(phi, ss, rotlvmp, coordinates1, ['C', 'C'], cell_height/2 - distance/2)
    fincoord2, species_2 = get_final_coord(phi, ss, rotlvmp, coordinates2, ['C', 'C'], cell_height/2 + distance/2)
    fincoords = [fincoord1, fincoord2]
    species_layers = [species_1, species_2]
    natom = get_natoms(fincoords)
    species_map = {
        (1, 'C'): 1,
        (2, 'C'): 2
    }
    write_files(prefix, rotlvmp, cell_height, ss, species_map, species_layers, fincoords)

def gen_geom(twist_degree, system, a=2.46, b=2.46, cell_height=60, distance1=3.4, distance2=3.4, ss=1):
    theta = (np.pi/180)*twist_degree
    latvec1a = a*np.array([1/np.sqrt(2),1/np.sqrt(2)])
    latvec1b = rotation_matrix(np.pi/3)[:2,:2].dot(latvec1a)
    lv1 = np.array([latvec1a, latvec1b])

    latvec_unrotated = b*np.array([1/np.sqrt(2),1/np.sqrt(2)])
    latvec2a = rotation_matrix(theta)[:2,:2].dot(latvec_unrotated)
    latvec2b = rotation_matrix(np.pi/3)[:2,:2].dot(latvec2a)
    lv2 = np.array([latvec2a, latvec2b])

    M = lv2.dot(np.linalg.inv(lv1))
    P = np.linalg.inv(np.identity(len(M)) - M).dot(M)
    lvm = P.dot(lv1)
    m = lvm.dot(np.linalg.inv(lv1))
    print(f'(m, n) = ({-m[0, 0]:.0f}, {m[1, 1]:.0f})')
    xmod = np.sqrt(np.square(lvm[0, 0]) + np.square(lvm[0, 1]))
    xaxis = [1, 0]
    lvmpx = np.array([lvm[0, 0],lvm[0, 1]])
    dotprod = lvmpx.dot(xaxis)/xmod
    phi = np.arccos(lvmpx.dot(xaxis)/xmod)
    phi0 = 180*phi/np.pi

    lvmp = np.array([
        [lvm[0, 0], lvm[0, 1]],
        [2*lvm[1, 0] - lvm[0, 0], 2*lvm[1, 1] - lvm[0, 1]]
        ])
    rotlvmp1 = rotation_matrix(-phi)[:2,:2].dot(lvmp[0])
    rotlvmp2 = rotation_matrix(-phi)[:2,:2].dot(lvmp[1])
    rotlvmp = [rotlvmp1, rotlvmp2]

    coordinates1 = get_coordinates(latvec1a, latvec1b, 0)
    coordinates2 = get_coordinates(latvec2a, latvec2b, 0)

    if system == 'cc-cc':
        gen_CCCC(phi, ss, rotlvmp, coordinates1, coordinates2, cell_height, distance1)

if __name__ == '__main__':
    # commensurate angles = 21.7867893, 13.17355112, 9.43000791, 6.0089832, 7.34099302, 5.08584781, 4.408455008, 3.89023817, 3.4...,
    # 2.875894634, 2.0046278307, 1.4701297259, 1.1606527199, 1.08454904924, 1.0501208798, 0.98743029788, 0.5050308328, 0.1000899404333
    for angle in [0.98743029788]:
        gen_geom(angle, 'cc-cc')
